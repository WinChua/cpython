/* File automatically generated by asdl_c.py. */

#include <stddef.h>

#include "Python.h"
#include "Fig3-ast.h"
#include "structmember.h"

typedef struct {
    int initialized;
    PyObject *Assign_type;
    PyObject *Compound_type;
    PyObject *Div_singleton;
    PyObject *Div_type;
    PyObject *ExpList_type;
    PyObject *Id_type;
    PyObject *Minus_singleton;
    PyObject *Minus_type;
    PyObject *Nil_type;
    PyObject *Num_type;
    PyObject *Op_type;
    PyObject *Plus_singleton;
    PyObject *Plus_type;
    PyObject *Print_type;
    PyObject *Times_singleton;
    PyObject *Times_type;
    PyObject *__dict__;
    PyObject *__module__;
    PyObject *_ast;
    PyObject *_attributes;
    PyObject *_fields;
    PyObject *args;
    PyObject *binop_type;
    PyObject *exp_list_type;
    PyObject *exp_type;
    PyObject *head;
    PyObject *id;
    PyObject *lval;
    PyObject *next;
    PyObject *num;
    PyObject *op;
    PyObject *rval;
    PyObject *stm_type;
} astmodulestate;


#define astmodulestate(o) ((astmodulestate *)PyModule_GetState(o))

static int astmodule_clear(PyObject *module)
{
    Py_CLEAR(astmodulestate(module)->Assign_type);
    Py_CLEAR(astmodulestate(module)->Compound_type);
    Py_CLEAR(astmodulestate(module)->Div_singleton);
    Py_CLEAR(astmodulestate(module)->Div_type);
    Py_CLEAR(astmodulestate(module)->ExpList_type);
    Py_CLEAR(astmodulestate(module)->Id_type);
    Py_CLEAR(astmodulestate(module)->Minus_singleton);
    Py_CLEAR(astmodulestate(module)->Minus_type);
    Py_CLEAR(astmodulestate(module)->Nil_type);
    Py_CLEAR(astmodulestate(module)->Num_type);
    Py_CLEAR(astmodulestate(module)->Op_type);
    Py_CLEAR(astmodulestate(module)->Plus_singleton);
    Py_CLEAR(astmodulestate(module)->Plus_type);
    Py_CLEAR(astmodulestate(module)->Print_type);
    Py_CLEAR(astmodulestate(module)->Times_singleton);
    Py_CLEAR(astmodulestate(module)->Times_type);
    Py_CLEAR(astmodulestate(module)->__dict__);
    Py_CLEAR(astmodulestate(module)->__module__);
    Py_CLEAR(astmodulestate(module)->_ast);
    Py_CLEAR(astmodulestate(module)->_attributes);
    Py_CLEAR(astmodulestate(module)->_fields);
    Py_CLEAR(astmodulestate(module)->args);
    Py_CLEAR(astmodulestate(module)->binop_type);
    Py_CLEAR(astmodulestate(module)->exp_list_type);
    Py_CLEAR(astmodulestate(module)->exp_type);
    Py_CLEAR(astmodulestate(module)->head);
    Py_CLEAR(astmodulestate(module)->id);
    Py_CLEAR(astmodulestate(module)->lval);
    Py_CLEAR(astmodulestate(module)->next);
    Py_CLEAR(astmodulestate(module)->num);
    Py_CLEAR(astmodulestate(module)->op);
    Py_CLEAR(astmodulestate(module)->rval);
    Py_CLEAR(astmodulestate(module)->stm_type);

    return 0;
}

static int astmodule_traverse(PyObject *module, visitproc visit, void* arg)
{
    Py_VISIT(astmodulestate(module)->Assign_type);
    Py_VISIT(astmodulestate(module)->Compound_type);
    Py_VISIT(astmodulestate(module)->Div_singleton);
    Py_VISIT(astmodulestate(module)->Div_type);
    Py_VISIT(astmodulestate(module)->ExpList_type);
    Py_VISIT(astmodulestate(module)->Id_type);
    Py_VISIT(astmodulestate(module)->Minus_singleton);
    Py_VISIT(astmodulestate(module)->Minus_type);
    Py_VISIT(astmodulestate(module)->Nil_type);
    Py_VISIT(astmodulestate(module)->Num_type);
    Py_VISIT(astmodulestate(module)->Op_type);
    Py_VISIT(astmodulestate(module)->Plus_singleton);
    Py_VISIT(astmodulestate(module)->Plus_type);
    Py_VISIT(astmodulestate(module)->Print_type);
    Py_VISIT(astmodulestate(module)->Times_singleton);
    Py_VISIT(astmodulestate(module)->Times_type);
    Py_VISIT(astmodulestate(module)->__dict__);
    Py_VISIT(astmodulestate(module)->__module__);
    Py_VISIT(astmodulestate(module)->_ast);
    Py_VISIT(astmodulestate(module)->_attributes);
    Py_VISIT(astmodulestate(module)->_fields);
    Py_VISIT(astmodulestate(module)->args);
    Py_VISIT(astmodulestate(module)->binop_type);
    Py_VISIT(astmodulestate(module)->exp_list_type);
    Py_VISIT(astmodulestate(module)->exp_type);
    Py_VISIT(astmodulestate(module)->head);
    Py_VISIT(astmodulestate(module)->id);
    Py_VISIT(astmodulestate(module)->lval);
    Py_VISIT(astmodulestate(module)->next);
    Py_VISIT(astmodulestate(module)->num);
    Py_VISIT(astmodulestate(module)->op);
    Py_VISIT(astmodulestate(module)->rval);
    Py_VISIT(astmodulestate(module)->stm_type);

    return 0;
}

static void astmodule_free(void* module) {
    astmodule_clear((PyObject*)module);
}

static struct PyModuleDef _astmodule = {
    PyModuleDef_HEAD_INIT,
    "_ast",
    NULL,
    sizeof(astmodulestate),
    NULL,
    NULL,
    astmodule_traverse,
    astmodule_clear,
    astmodule_free,
};

#define astmodulestate_global ((astmodulestate *)PyModule_GetState(PyState_FindModule(&_astmodule)))

static int init_identifiers(void)
{
    astmodulestate *state = astmodulestate_global;
    if ((state->__dict__ = PyUnicode_InternFromString("__dict__")) == NULL) return 0;
    if ((state->__module__ = PyUnicode_InternFromString("__module__")) == NULL) return 0;
    if ((state->_ast = PyUnicode_InternFromString("_ast")) == NULL) return 0;
    if ((state->_attributes = PyUnicode_InternFromString("_attributes")) == NULL) return 0;
    if ((state->_fields = PyUnicode_InternFromString("_fields")) == NULL) return 0;
    if ((state->args = PyUnicode_InternFromString("args")) == NULL) return 0;
    if ((state->head = PyUnicode_InternFromString("head")) == NULL) return 0;
    if ((state->id = PyUnicode_InternFromString("id")) == NULL) return 0;
    if ((state->lval = PyUnicode_InternFromString("lval")) == NULL) return 0;
    if ((state->next = PyUnicode_InternFromString("next")) == NULL) return 0;
    if ((state->num = PyUnicode_InternFromString("num")) == NULL) return 0;
    if ((state->op = PyUnicode_InternFromString("op")) == NULL) return 0;
    if ((state->rval = PyUnicode_InternFromString("rval")) == NULL) return 0;
    return 1;
};

static PyObject* ast2obj_stm(void*);
static const char * const Compound_fields[]={
    "head",
    "next",
};
static const char * const Assign_fields[]={
    "lval",
    "rval",
};
static const char * const Print_fields[]={
    "args",
};
static PyObject* ast2obj_exp_list(void*);
static const char * const ExpList_fields[]={
    "head",
    "next",
};
static PyObject* ast2obj_exp(void*);
static const char * const Id_fields[]={
    "id",
};
static const char * const Num_fields[]={
    "num",
};
static const char * const Op_fields[]={
    "lval",
    "op",
    "rval",
};
static PyObject* ast2obj_binop(binop_ty);



typedef struct {
    PyObject_HEAD
    PyObject *dict;
} AST_object;

static void
ast_dealloc(AST_object *self)
{
    /* bpo-31095: UnTrack is needed before calling any callbacks */
    PyTypeObject *tp = Py_TYPE(self);
    PyObject_GC_UnTrack(self);
    Py_CLEAR(self->dict);
    freefunc free_func = PyType_GetSlot(tp, Py_tp_free);
    assert(free_func != NULL);
    free_func(self);
    Py_DECREF(tp);
}

static int
ast_traverse(AST_object *self, visitproc visit, void *arg)
{
    Py_VISIT(self->dict);
    return 0;
}

static int
ast_clear(AST_object *self)
{
    Py_CLEAR(self->dict);
    return 0;
}

static int
ast_type_init(PyObject *self, PyObject *args, PyObject *kw)
{
    Py_ssize_t i, numfields = 0;
    int res = -1;
    PyObject *key, *value, *fields;
    if (_PyObject_LookupAttr((PyObject*)Py_TYPE(self), astmodulestate_global->_fields, &fields) < 0) {
        goto cleanup;
    }
    if (fields) {
        numfields = PySequence_Size(fields);
        if (numfields == -1)
            goto cleanup;
    }

    res = 0; /* if no error occurs, this stays 0 to the end */
    if (numfields < PyTuple_GET_SIZE(args)) {
        PyErr_Format(PyExc_TypeError, "%.400s constructor takes at most "
                     "%zd positional argument%s",
                     _PyType_Name(Py_TYPE(self)),
                     numfields, numfields == 1 ? "" : "s");
        res = -1;
        goto cleanup;
    }
    for (i = 0; i < PyTuple_GET_SIZE(args); i++) {
        /* cannot be reached when fields is NULL */
        PyObject *name = PySequence_GetItem(fields, i);
        if (!name) {
            res = -1;
            goto cleanup;
        }
        res = PyObject_SetAttr(self, name, PyTuple_GET_ITEM(args, i));
        Py_DECREF(name);
        if (res < 0)
            goto cleanup;
    }
    if (kw) {
        i = 0;  /* needed by PyDict_Next */
        while (PyDict_Next(kw, &i, &key, &value)) {
            res = PyObject_SetAttr(self, key, value);
            if (res < 0)
                goto cleanup;
        }
    }
  cleanup:
    Py_XDECREF(fields);
    return res;
}

/* Pickling support */
static PyObject *
ast_type_reduce(PyObject *self, PyObject *unused)
{
    PyObject *dict;
    if (_PyObject_LookupAttr(self, astmodulestate_global->__dict__, &dict) < 0) {
        return NULL;
    }
    if (dict) {
        return Py_BuildValue("O()N", Py_TYPE(self), dict);
    }
    return Py_BuildValue("O()", Py_TYPE(self));
}

static PyMemberDef ast_type_members[] = {
    {"__dictoffset__", T_PYSSIZET, offsetof(AST_object, dict), READONLY},
    {NULL}  /* Sentinel */
};

static PyMethodDef ast_type_methods[] = {
    {"__reduce__", ast_type_reduce, METH_NOARGS, NULL},
    {NULL}
};

static PyGetSetDef ast_type_getsets[] = {
    {"__dict__", PyObject_GenericGetDict, PyObject_GenericSetDict},
    {NULL}
};

static PyType_Slot AST_type_slots[] = {
    {Py_tp_dealloc, ast_dealloc},
    {Py_tp_getattro, PyObject_GenericGetAttr},
    {Py_tp_setattro, PyObject_GenericSetAttr},
    {Py_tp_traverse, ast_traverse},
    {Py_tp_clear, ast_clear},
    {Py_tp_members, ast_type_members},
    {Py_tp_methods, ast_type_methods},
    {Py_tp_getset, ast_type_getsets},
    {Py_tp_init, ast_type_init},
    {Py_tp_alloc, PyType_GenericAlloc},
    {Py_tp_new, PyType_GenericNew},
    {Py_tp_free, PyObject_GC_Del},
    {0, 0},
};

static PyType_Spec AST_type_spec = {
    "_ast.AST",
    sizeof(AST_object),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
    AST_type_slots
};

static PyObject *
make_type(const char *type, PyObject* base, const char* const* fields, int num_fields)
{
    PyObject *fnames, *result;
    int i;
    fnames = PyTuple_New(num_fields);
    if (!fnames) return NULL;
    for (i = 0; i < num_fields; i++) {
        PyObject *field = PyUnicode_InternFromString(fields[i]);
        if (!field) {
            Py_DECREF(fnames);
            return NULL;
        }
        PyTuple_SET_ITEM(fnames, i, field);
    }
    result = PyObject_CallFunction((PyObject*)&PyType_Type, "s(O){OOOO}",
                    type, base,
                    astmodulestate_global->_fields, fnames,
                    astmodulestate_global->__module__,
                    astmodulestate_global->_ast);
    Py_DECREF(fnames);
    return result;
}

static int
add_attributes(PyObject *type, const char * const *attrs, int num_fields)
{
    int i, result;
    PyObject *s, *l = PyTuple_New(num_fields);
    if (!l)
        return 0;
    for (i = 0; i < num_fields; i++) {
        s = PyUnicode_InternFromString(attrs[i]);
        if (!s) {
            Py_DECREF(l);
            return 0;
        }
        PyTuple_SET_ITEM(l, i, s);
    }
    result = PyObject_SetAttr(type, astmodulestate_global->_attributes, l) >= 0;
    Py_DECREF(l);
    return result;
}

/* Conversion AST -> Python */

static PyObject* ast2obj_list(asdl_seq *seq, PyObject* (*func)(void*))
{
    Py_ssize_t i, n = asdl_seq_LEN(seq);
    PyObject *result = PyList_New(n);
    PyObject *value;
    if (!result)
        return NULL;
    for (i = 0; i < n; i++) {
        value = func(asdl_seq_GET(seq, i));
        if (!value) {
            Py_DECREF(result);
            return NULL;
        }
        PyList_SET_ITEM(result, i, value);
    }
    return result;
}

static PyObject* ast2obj_object(void *o)
{
    if (!o)
        o = Py_None;
    Py_INCREF((PyObject*)o);
    return (PyObject*)o;
}
#define ast2obj_singleton ast2obj_object
#define ast2obj_constant ast2obj_object
#define ast2obj_identifier ast2obj_object
#define ast2obj_string ast2obj_object
#define ast2obj_bytes ast2obj_object

static PyObject* ast2obj_int(long b)
{
    return PyLong_FromLong(b);
}

/* Conversion Python -> AST */

static int obj2ast_object(PyObject* obj, PyObject** out, PyArena* arena)
{
    if (obj == Py_None)
        obj = NULL;
    if (obj) {
        if (PyArena_AddPyObject(arena, obj) < 0) {
            *out = NULL;
            return -1;
        }
        Py_INCREF(obj);
    }
    *out = obj;
    return 0;
}

static int obj2ast_constant(PyObject* obj, PyObject** out, PyArena* arena)
{
    if (PyArena_AddPyObject(arena, obj) < 0) {
        *out = NULL;
        return -1;
    }
    Py_INCREF(obj);
    *out = obj;
    return 0;
}

static int obj2ast_identifier(PyObject* obj, PyObject** out, PyArena* arena)
{
    if (!PyUnicode_CheckExact(obj) && obj != Py_None) {
        PyErr_SetString(PyExc_TypeError, "AST identifier must be of type str");
        return 1;
    }
    return obj2ast_object(obj, out, arena);
}

static int obj2ast_string(PyObject* obj, PyObject** out, PyArena* arena)
{
    if (!PyUnicode_CheckExact(obj) && !PyBytes_CheckExact(obj)) {
        PyErr_SetString(PyExc_TypeError, "AST string must be of type str");
        return 1;
    }
    return obj2ast_object(obj, out, arena);
}

static int obj2ast_int(PyObject* obj, int* out, PyArena* arena)
{
    int i;
    if (!PyLong_Check(obj)) {
        PyErr_Format(PyExc_ValueError, "invalid integer value: %R", obj);
        return 1;
    }

    i = _PyLong_AsInt(obj);
    if (i == -1 && PyErr_Occurred())
        return 1;
    *out = i;
    return 0;
}

static int add_ast_fields(void)
{
    PyObject *empty_tuple;
    empty_tuple = PyTuple_New(0);
    if (!empty_tuple ||
        PyObject_SetAttrString(astmodulestate_global->AST_type, "_fields", empty_tuple) < 0 ||
        PyObject_SetAttrString(astmodulestate_global->AST_type, "_attributes", empty_tuple) < 0) {
        Py_XDECREF(empty_tuple);
        return -1;
    }
    Py_DECREF(empty_tuple);
    return 0;
}


static int init_types(void)
{
    PyObject *m;
    if (PyState_FindModule(&_astmodule) == NULL) {
        m = PyModule_Create(&_astmodule);
        if (!m) return 0;
        PyState_AddModule(m, &_astmodule);
    }
    astmodulestate *state = astmodulestate_global;
    if (state->initialized) return 1;
    if (init_identifiers() < 0) return 0;
    state->AST_type = PyType_FromSpec(&AST_type_spec);
    if (!state->AST_type) return 0;
    if (add_ast_fields() < 0) return 0;
    state->stm_type = make_type("stm", state->AST_type, NULL, 0);
    if (!state->stm_type) return 0;
    if (!add_attributes(state->stm_type, NULL, 0)) return 0;
    state->Compound_type = make_type("Compound", state->stm_type,
                                     Compound_fields, 2);
    if (!state->Compound_type) return 0;
    state->Assign_type = make_type("Assign", state->stm_type, Assign_fields, 2);
    if (!state->Assign_type) return 0;
    state->Print_type = make_type("Print", state->stm_type, Print_fields, 1);
    if (!state->Print_type) return 0;
    state->exp_list_type = make_type("exp_list", state->AST_type, NULL, 0);
    if (!state->exp_list_type) return 0;
    if (!add_attributes(state->exp_list_type, NULL, 0)) return 0;
    state->ExpList_type = make_type("ExpList", state->exp_list_type,
                                    ExpList_fields, 2);
    if (!state->ExpList_type) return 0;
    state->Nil_type = make_type("Nil", state->exp_list_type, NULL, 0);
    if (!state->Nil_type) return 0;
    state->exp_type = make_type("exp", state->AST_type, NULL, 0);
    if (!state->exp_type) return 0;
    if (!add_attributes(state->exp_type, NULL, 0)) return 0;
    state->Id_type = make_type("Id", state->exp_type, Id_fields, 1);
    if (!state->Id_type) return 0;
    state->Num_type = make_type("Num", state->exp_type, Num_fields, 1);
    if (!state->Num_type) return 0;
    state->Op_type = make_type("Op", state->exp_type, Op_fields, 3);
    if (!state->Op_type) return 0;
    state->binop_type = make_type("binop", state->AST_type, NULL, 0);
    if (!state->binop_type) return 0;
    if (!add_attributes(state->binop_type, NULL, 0)) return 0;
    state->Plus_type = make_type("Plus", state->binop_type, NULL, 0);
    if (!state->Plus_type) return 0;
    state->Plus_singleton = PyType_GenericNew((PyTypeObject *)state->Plus_type,
                                              NULL, NULL);
    if (!state->Plus_singleton) return 0;
    state->Minus_type = make_type("Minus", state->binop_type, NULL, 0);
    if (!state->Minus_type) return 0;
    state->Minus_singleton = PyType_GenericNew((PyTypeObject
                                               *)state->Minus_type, NULL, NULL);
    if (!state->Minus_singleton) return 0;
    state->Times_type = make_type("Times", state->binop_type, NULL, 0);
    if (!state->Times_type) return 0;
    state->Times_singleton = PyType_GenericNew((PyTypeObject
                                               *)state->Times_type, NULL, NULL);
    if (!state->Times_singleton) return 0;
    state->Div_type = make_type("Div", state->binop_type, NULL, 0);
    if (!state->Div_type) return 0;
    state->Div_singleton = PyType_GenericNew((PyTypeObject *)state->Div_type,
                                             NULL, NULL);
    if (!state->Div_singleton) return 0;
    state->initialized = 1;
    return 1;
}

static int obj2ast_stm(PyObject* obj, stm_ty* out, PyArena* arena);
static int obj2ast_exp_list(PyObject* obj, exp_list_ty* out, PyArena* arena);
static int obj2ast_exp(PyObject* obj, exp_ty* out, PyArena* arena);
static int obj2ast_binop(PyObject* obj, binop_ty* out, PyArena* arena);

stm_ty
Compound(stm_ty head, stm_ty next, PyArena *arena)
{
    stm_ty p;
    if (!head) {
        PyErr_SetString(PyExc_ValueError,
                        "field head is required for Compound");
        return NULL;
    }
    if (!next) {
        PyErr_SetString(PyExc_ValueError,
                        "field next is required for Compound");
        return NULL;
    }
    p = (stm_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Compound_kind;
    p->v.Compound.head = head;
    p->v.Compound.next = next;
    return p;
}

stm_ty
Assign(identifier lval, exp_ty rval, PyArena *arena)
{
    stm_ty p;
    if (!lval) {
        PyErr_SetString(PyExc_ValueError,
                        "field lval is required for Assign");
        return NULL;
    }
    if (!rval) {
        PyErr_SetString(PyExc_ValueError,
                        "field rval is required for Assign");
        return NULL;
    }
    p = (stm_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Assign_kind;
    p->v.Assign.lval = lval;
    p->v.Assign.rval = rval;
    return p;
}

stm_ty
Print(exp_list_ty args, PyArena *arena)
{
    stm_ty p;
    if (!args) {
        PyErr_SetString(PyExc_ValueError,
                        "field args is required for Print");
        return NULL;
    }
    p = (stm_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Print_kind;
    p->v.Print.args = args;
    return p;
}

exp_list_ty
ExpList(exp_ty head, exp_list_ty next, PyArena *arena)
{
    exp_list_ty p;
    if (!head) {
        PyErr_SetString(PyExc_ValueError,
                        "field head is required for ExpList");
        return NULL;
    }
    if (!next) {
        PyErr_SetString(PyExc_ValueError,
                        "field next is required for ExpList");
        return NULL;
    }
    p = (exp_list_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = ExpList_kind;
    p->v.ExpList.head = head;
    p->v.ExpList.next = next;
    return p;
}

exp_list_ty
Nil(PyArena *arena)
{
    exp_list_ty p;
    p = (exp_list_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Nil_kind;
    return p;
}

exp_ty
Id(identifier id, PyArena *arena)
{
    exp_ty p;
    if (!id) {
        PyErr_SetString(PyExc_ValueError,
                        "field id is required for Id");
        return NULL;
    }
    p = (exp_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Id_kind;
    p->v.Id.id = id;
    return p;
}

exp_ty
Num(int num, PyArena *arena)
{
    exp_ty p;
    p = (exp_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Num_kind;
    p->v.Num.num = num;
    return p;
}

exp_ty
Op(exp_ty lval, binop_ty op, exp_ty rval, PyArena *arena)
{
    exp_ty p;
    if (!lval) {
        PyErr_SetString(PyExc_ValueError,
                        "field lval is required for Op");
        return NULL;
    }
    if (!op) {
        PyErr_SetString(PyExc_ValueError,
                        "field op is required for Op");
        return NULL;
    }
    if (!rval) {
        PyErr_SetString(PyExc_ValueError,
                        "field rval is required for Op");
        return NULL;
    }
    p = (exp_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Op_kind;
    p->v.Op.lval = lval;
    p->v.Op.op = op;
    p->v.Op.rval = rval;
    return p;
}


PyObject*
ast2obj_stm(void* _o)
{
    stm_ty o = (stm_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }

    switch (o->kind) {
    case Compound_kind:
        tp = (PyTypeObject *)astmodulestate_global->Compound_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_stm(o->v.Compound.head);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, astmodulestate_global->head, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_stm(o->v.Compound.next);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, astmodulestate_global->next, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Assign_kind:
        tp = (PyTypeObject *)astmodulestate_global->Assign_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.Assign.lval);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, astmodulestate_global->lval, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_exp(o->v.Assign.rval);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, astmodulestate_global->rval, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Print_kind:
        tp = (PyTypeObject *)astmodulestate_global->Print_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_exp_list(o->v.Print.args);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, astmodulestate_global->args, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}

PyObject*
ast2obj_exp_list(void* _o)
{
    exp_list_ty o = (exp_list_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }

    switch (o->kind) {
    case ExpList_kind:
        tp = (PyTypeObject *)astmodulestate_global->ExpList_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_exp(o->v.ExpList.head);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, astmodulestate_global->head, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_exp_list(o->v.ExpList.next);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, astmodulestate_global->next, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Nil_kind:
        tp = (PyTypeObject *)astmodulestate_global->Nil_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        break;
    }
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}

PyObject*
ast2obj_exp(void* _o)
{
    exp_ty o = (exp_ty)_o;
    PyObject *result = NULL, *value = NULL;
    PyTypeObject *tp;
    if (!o) {
        Py_RETURN_NONE;
    }

    switch (o->kind) {
    case Id_kind:
        tp = (PyTypeObject *)astmodulestate_global->Id_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_identifier(o->v.Id.id);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, astmodulestate_global->id, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Num_kind:
        tp = (PyTypeObject *)astmodulestate_global->Num_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_int(o->v.Num.num);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, astmodulestate_global->num, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    case Op_kind:
        tp = (PyTypeObject *)astmodulestate_global->Op_type;
        result = PyType_GenericNew(tp, NULL, NULL);
        if (!result) goto failed;
        value = ast2obj_exp(o->v.Op.lval);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, astmodulestate_global->lval, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_binop(o->v.Op.op);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, astmodulestate_global->op, value) == -1)
            goto failed;
        Py_DECREF(value);
        value = ast2obj_exp(o->v.Op.rval);
        if (!value) goto failed;
        if (PyObject_SetAttr(result, astmodulestate_global->rval, value) == -1)
            goto failed;
        Py_DECREF(value);
        break;
    }
    return result;
failed:
    Py_XDECREF(value);
    Py_XDECREF(result);
    return NULL;
}

PyObject* ast2obj_binop(binop_ty o)
{
    switch(o) {
        case Plus:
            Py_INCREF(astmodulestate_global->Plus_singleton);
            return astmodulestate_global->Plus_singleton;
        case Minus:
            Py_INCREF(astmodulestate_global->Minus_singleton);
            return astmodulestate_global->Minus_singleton;
        case Times:
            Py_INCREF(astmodulestate_global->Times_singleton);
            return astmodulestate_global->Times_singleton;
        case Div:
            Py_INCREF(astmodulestate_global->Div_singleton);
            return astmodulestate_global->Div_singleton;
        default:
            /* should never happen, but just in case ... */
            PyErr_Format(PyExc_SystemError, "unknown binop found");
            return NULL;
    }
}

int
obj2ast_stm(PyObject* obj, stm_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;
    PyObject *tp;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    tp = astmodulestate_global->Compound_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        stm_ty head;
        stm_ty next;

        if (_PyObject_LookupAttr(obj, astmodulestate_global->head, &tmp) < 0) {
            return 1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"head\" missing from Compound");
            return 1;
        }
        else {
            int res;
            res = obj2ast_stm(tmp, &head, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (_PyObject_LookupAttr(obj, astmodulestate_global->next, &tmp) < 0) {
            return 1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"next\" missing from Compound");
            return 1;
        }
        else {
            int res;
            res = obj2ast_stm(tmp, &next, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = Compound(head, next, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = astmodulestate_global->Assign_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        identifier lval;
        exp_ty rval;

        if (_PyObject_LookupAttr(obj, astmodulestate_global->lval, &tmp) < 0) {
            return 1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"lval\" missing from Assign");
            return 1;
        }
        else {
            int res;
            res = obj2ast_identifier(tmp, &lval, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (_PyObject_LookupAttr(obj, astmodulestate_global->rval, &tmp) < 0) {
            return 1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"rval\" missing from Assign");
            return 1;
        }
        else {
            int res;
            res = obj2ast_exp(tmp, &rval, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = Assign(lval, rval, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = astmodulestate_global->Print_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        exp_list_ty args;

        if (_PyObject_LookupAttr(obj, astmodulestate_global->args, &tmp) < 0) {
            return 1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"args\" missing from Print");
            return 1;
        }
        else {
            int res;
            res = obj2ast_exp_list(tmp, &args, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = Print(args, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of stm, but got %R", obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}

int
obj2ast_exp_list(PyObject* obj, exp_list_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;
    PyObject *tp;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    tp = astmodulestate_global->ExpList_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        exp_ty head;
        exp_list_ty next;

        if (_PyObject_LookupAttr(obj, astmodulestate_global->head, &tmp) < 0) {
            return 1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"head\" missing from ExpList");
            return 1;
        }
        else {
            int res;
            res = obj2ast_exp(tmp, &head, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (_PyObject_LookupAttr(obj, astmodulestate_global->next, &tmp) < 0) {
            return 1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"next\" missing from ExpList");
            return 1;
        }
        else {
            int res;
            res = obj2ast_exp_list(tmp, &next, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = ExpList(head, next, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = astmodulestate_global->Nil_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {

        *out = Nil(arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of exp_list, but got %R", obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}

int
obj2ast_exp(PyObject* obj, exp_ty* out, PyArena* arena)
{
    int isinstance;

    PyObject *tmp = NULL;
    PyObject *tp;

    if (obj == Py_None) {
        *out = NULL;
        return 0;
    }
    tp = astmodulestate_global->Id_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        identifier id;

        if (_PyObject_LookupAttr(obj, astmodulestate_global->id, &tmp) < 0) {
            return 1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"id\" missing from Id");
            return 1;
        }
        else {
            int res;
            res = obj2ast_identifier(tmp, &id, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = Id(id, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = astmodulestate_global->Num_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        int num;

        if (_PyObject_LookupAttr(obj, astmodulestate_global->num, &tmp) < 0) {
            return 1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"num\" missing from Num");
            return 1;
        }
        else {
            int res;
            res = obj2ast_int(tmp, &num, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = Num(num, arena);
        if (*out == NULL) goto failed;
        return 0;
    }
    tp = astmodulestate_global->Op_type;
    isinstance = PyObject_IsInstance(obj, tp);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        exp_ty lval;
        binop_ty op;
        exp_ty rval;

        if (_PyObject_LookupAttr(obj, astmodulestate_global->lval, &tmp) < 0) {
            return 1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"lval\" missing from Op");
            return 1;
        }
        else {
            int res;
            res = obj2ast_exp(tmp, &lval, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (_PyObject_LookupAttr(obj, astmodulestate_global->op, &tmp) < 0) {
            return 1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"op\" missing from Op");
            return 1;
        }
        else {
            int res;
            res = obj2ast_binop(tmp, &op, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        if (_PyObject_LookupAttr(obj, astmodulestate_global->rval, &tmp) < 0) {
            return 1;
        }
        if (tmp == NULL) {
            PyErr_SetString(PyExc_TypeError, "required field \"rval\" missing from Op");
            return 1;
        }
        else {
            int res;
            res = obj2ast_exp(tmp, &rval, arena);
            if (res != 0) goto failed;
            Py_CLEAR(tmp);
        }
        *out = Op(lval, op, rval, arena);
        if (*out == NULL) goto failed;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of exp, but got %R", obj);
    failed:
    Py_XDECREF(tmp);
    return 1;
}

int
obj2ast_binop(PyObject* obj, binop_ty* out, PyArena* arena)
{
    int isinstance;

    isinstance = PyObject_IsInstance(obj, astmodulestate_global->Plus_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = Plus;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, astmodulestate_global->Minus_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = Minus;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, astmodulestate_global->Times_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = Times;
        return 0;
    }
    isinstance = PyObject_IsInstance(obj, astmodulestate_global->Div_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        *out = Div;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of binop, but got %R", obj);
    return 1;
}


PyMODINIT_FUNC
PyInit__ast(void)
{
    PyObject *m;
    if (!init_types()) return NULL;
    m = PyState_FindModule(&_astmodule);
    if (!m) return NULL;
    if (PyModule_AddObject(m, "AST", astmodulestate_global->AST_type) < 0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->AST_type);
    if (PyModule_AddIntMacro(m, PyCF_ALLOW_TOP_LEVEL_AWAIT) < 0) {
        goto error;
    }
    if (PyModule_AddIntMacro(m, PyCF_ONLY_AST) < 0) {
        goto error;
    }
    if (PyModule_AddIntMacro(m, PyCF_TYPE_COMMENTS) < 0) {
        goto error;
    }
    if (PyModule_AddObject(m, "stm", astmodulestate_global->stm_type) < 0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->stm_type);
    if (PyModule_AddObject(m, "Compound", astmodulestate_global->Compound_type)
        < 0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->Compound_type);
    if (PyModule_AddObject(m, "Assign", astmodulestate_global->Assign_type) <
        0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->Assign_type);
    if (PyModule_AddObject(m, "Print", astmodulestate_global->Print_type) < 0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->Print_type);
    if (PyModule_AddObject(m, "exp_list", astmodulestate_global->exp_list_type)
        < 0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->exp_list_type);
    if (PyModule_AddObject(m, "ExpList", astmodulestate_global->ExpList_type) <
        0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->ExpList_type);
    if (PyModule_AddObject(m, "Nil", astmodulestate_global->Nil_type) < 0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->Nil_type);
    if (PyModule_AddObject(m, "exp", astmodulestate_global->exp_type) < 0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->exp_type);
    if (PyModule_AddObject(m, "Id", astmodulestate_global->Id_type) < 0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->Id_type);
    if (PyModule_AddObject(m, "Num", astmodulestate_global->Num_type) < 0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->Num_type);
    if (PyModule_AddObject(m, "Op", astmodulestate_global->Op_type) < 0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->Op_type);
    if (PyModule_AddObject(m, "binop", astmodulestate_global->binop_type) < 0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->binop_type);
    if (PyModule_AddObject(m, "Plus", astmodulestate_global->Plus_type) < 0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->Plus_type);
    if (PyModule_AddObject(m, "Minus", astmodulestate_global->Minus_type) < 0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->Minus_type);
    if (PyModule_AddObject(m, "Times", astmodulestate_global->Times_type) < 0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->Times_type);
    if (PyModule_AddObject(m, "Div", astmodulestate_global->Div_type) < 0) {
        goto error;
    }
    Py_INCREF(astmodulestate(m)->Div_type);
    return m;
error:
    Py_DECREF(m);
    return NULL;
}


PyObject* PyAST_mod2obj(mod_ty t)
{
    if (!init_types())
        return NULL;
    return ast2obj_mod(t);
}

/* mode is 0 for "exec", 1 for "eval" and 2 for "single" input */
mod_ty PyAST_obj2mod(PyObject* ast, PyArena* arena, int mode)
{
    PyObject *req_type[3];
    const char * const req_name[] = {"Module", "Expression", "Interactive"};
    int isinstance;

    if (PySys_Audit("compile", "OO", ast, Py_None) < 0) {
        return NULL;
    }

    req_type[0] = astmodulestate_global->Module_type;
    req_type[1] = astmodulestate_global->Expression_type;
    req_type[2] = astmodulestate_global->Interactive_type;

    assert(0 <= mode && mode <= 2);

    if (!init_types())
        return NULL;

    isinstance = PyObject_IsInstance(ast, req_type[mode]);
    if (isinstance == -1)
        return NULL;
    if (!isinstance) {
        PyErr_Format(PyExc_TypeError, "expected %s node, got %.400s",
                     req_name[mode], _PyType_Name(Py_TYPE(ast)));
        return NULL;
    }

    mod_ty res = NULL;
    if (obj2ast_mod(ast, &res, arena) != 0)
        return NULL;
    else
        return res;
}

int PyAST_Check(PyObject* obj)
{
    if (!init_types())
        return -1;
    return PyObject_IsInstance(obj, astmodulestate_global->AST_type);
}


